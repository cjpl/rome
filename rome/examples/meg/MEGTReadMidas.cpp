//// Author: 
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// MEGTReadMidas                                                              //
//                                                                            //
// Reads Midas Data.                                                            
// 
// 
// This header has been generated by the ROMEBuilder.
// The event methods have been written by .
// 
// Please note: The following information is only correct after executing the
//              ROMEBuilder.
// 
// This task accesses the following folders :
//    CMPMTData
//    CMPMTInfo
// 
//                                                                            //
/////////////////////////////////////----///////////////////////////////////////

#if defined( _MSC_VER )
#include <io.h>
#define O_RDONLY_BINARY O_RDONLY | O_BINARY
#endif
#if defined ( __linux__ )
#include <unistd.h>
#include <stdlib.h>
#include <sys/io.h>
#include <sys/types.h>
#include <sys/stat.h>
#define O_RDONLY_BINARY O_RDONLY
#endif

#include <TFile.h>
#include <ROME.h>
#include <include/generated/MEGTReadMidas.h>
#include <Riostream.h>

ClassImp(MEGTReadMidas)


void MEGTReadMidas::Init()
{
}

void MEGTReadMidas::BeginOfRun()
{
}
void MEGTReadMidas::Event()
{
   gAnalyzer->GetTest()->SetArrayAt(0,2);
   gAnalyzer->GetTest()->SetArrayAt(1,9);
   gAnalyzer->GetTest()->SetArrayAt(2,7);
   gAnalyzer->GetTest()->SetArrayAt(3,6);
/*   ROMEString path = "/Trigger/Eventnumber";
   int code = GetObjectInterpreterCode(path);
   cout << GetObjectInterpreterCharValue(code,"-999") << endl;
*/
/*   float ff[3] = {1.2*ii,3.5*ii,6.7*ii};
   TVectorF *vec = new TVectorF(3,ff);
   gAnalyzer->GettestAt(0)->Settest(vec);
   ii++;*/
//   cout << gAnalyzer->GettestAt(0)->Gettest()->operator[](0) << endl;
//   cout << gAnalyzer->GettestAt(0)->Gettest()->operator[](1) << endl;
//   cout << gAnalyzer->GettestAt(0)->Gettest()->operator[](2) << endl;
   //   cout << gAnalyzer->GetEventID() << endl;
   // Read Midas Banks and fill theme to folder
   float invalid = gAnalyzer->GetGSP()->GetInvalidValue();

   const int nPMT = gAnalyzer->GetGSP()->GetPMT()->GetNumbers()->GetNumberOfLXePMT();
   const int nFTDC = gAnalyzer->GetGSP()->GetPMT()->GetNumbers()->GetNumberOfFTDC();
   const int nCTDC = gAnalyzer->GetGSP()->GetPMT()->GetNumbers()->GetNumberOfCTDC();
   const int nVTDC = gAnalyzer->GetGSP()->GetPMT()->GetNumbers()->GetNumberOfVTDC();

   Int_t i;
   Float_t  *vfTDC = new Float_t[nPMT];
   int channel=0;float time=0,k;
   int n_f,n_c,n_v;

   // Read Banks

   // TDC Banks
   n_f = gAnalyzer->GetMidas()->GetFTDCBankEntries();
   n_c = gAnalyzer->GetMidas()->GetCTDCBankEntries();
   if (n_f == nFTDC && n_c == nCTDC) {
      for (i=nFTDC;i<nPMT;i++) vfTDC[i] = invalid;
 
      // FTDC Bank
      for (i=0;i<nFTDC;i++) {
         vfTDC[i] = (Float_t)(0.025f*gAnalyzer->GetMidas()->GetFTDCBankAt(i)->data);
      }

      // CTDC Bank
      for (i=0;i<nCTDC;i++) {
         for (k=0,channel=0 ; k<5 && (int)(gAnalyzer->GetMidas()->GetCTDCBankAt(i)>>16) != 19+k ; k++){
            channel += 16;
         }
         channel += (gAnalyzer->GetMidas()->GetCTDCBankAt(i) >> 12) & 0xF;
         channel += nFTDC;
         time = (float) (gAnalyzer->GetMidas()->GetCTDCBankAt(i) & 0xFFF);
         if (time >= 1.f && time < 4096.0f) {
            time *= 0.025f;
            if(channel < nFTDC + nCTDC) {
               vfTDC[channel] = time;
            }
         }
         else vfTDC[channel] = invalid;
      }

      // VTDC Bank
      n_v = gAnalyzer->GetMidas()->GetVTDCBankEntries();
      for (i=0;i<n_v;i++) {
         if(gAnalyzer->GetMidas()->GetVTDCBankAt(i)->tag == 0) {//( tag = 0:data, 2:header, 4:EOB 
	         channel = nFTDC + nCTDC; // put VME TDCs after FB&Camac TDCs 
	         channel += gAnalyzer->GetMidas()->GetVTDCBankAt(i)->geo_addr*32;
	         channel += gAnalyzer->GetMidas()->GetVTDCBankAt(i)->channel;
	         time = gAnalyzer->GetMidas()->GetVTDCBankAt(i)->data;
	         // convert to ns 
	         time *= 0.035f;
	         if (channel < nPMT) {
               // fill histos with TDC value 
	            vfTDC[channel] = time;
            }
         }
      }
   }
   else {
      gAnalyzer->SetFillEvent(false);
      delete vfTDC;
      return;
   }
   // write data to folder
   int iadc,itdc;
   for (i=0;i<nPMT;i++) {
      iadc = gAnalyzer->GetCMPMTInfoAt(i)->GetADCID();
      itdc = gAnalyzer->GetCMPMTInfoAt(i)->GetTDCID();
      gAnalyzer->GetCMPMTDataAt(i)->SetADC0Data((Float_t)gAnalyzer->GetMidas()->GetADCBankAt(0,iadc));
      gAnalyzer->GetCMPMTDataAt(i)->SetADC1Data((Float_t)gAnalyzer->GetMidas()->GetADCBankAt(1,iadc));
      gAnalyzer->GetCMPMTDataAt(i)->SetTDCData(vfTDC[itdc]);
   }
//   if (gAnalyzer->GetCurrentEventNumber()==1234)
//      this->StartRootInterpreter("End of Task");

   delete vfTDC;
   return;
}

void MEGTReadMidas::EndOfRun()
{
   ROMEStr2DArray *values = new ROMEStr2DArray(1,1);
   ROMEString str;
   str.SetFormatted("/odb/dir[@name=\"root\"]/dir[@name=\"System\"]/dir[@name=\"Clients\"]/dir[@name=\"3024\"]/key[@name=\"Server Port\"]");
//   gAnalyzer->GetODBDataBase()->Read(values,str.Data(),0);
//   cout << values->At(0,0) << endl;
//   cout << gAnalyzer->GetODB()->GetServerPort() << endl;
}

void MEGTReadMidas::Terminate()
{
}


