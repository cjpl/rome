////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// REFTClustering                                                             //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     Hit                                                                    //
//     Cluster                                                                //
//     MainCluster                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/REFTClusteringGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

#include "generated/REFAnalyzer.h"
#include "tasks/REFTClustering.h"
#include "ROMEiostream.h"

// uncomment if you want to include headers of all folders
//#include "REFAllFolders.h"


ClassImp(REFTClustering)

//______________________________________________________________________________
void REFTClustering::Init()
{
}

//______________________________________________________________________________
void REFTClustering::BeginOfRun()
{
}

//______________________________________________________________________________
void REFTClustering::Event()
{
   // Clusterring hits.
   // This clustering algorithm is not very sophisticated. Simply grouping hits in certain area.

   const Int_t kMaxCluster = 4 * 4 * 4 * 4;
   Int_t       iCluster;
   TObjArray **cluster = new TObjArray*[kMaxCluster];
   TArrayI    *hitID = new TArrayI[kMaxCluster];
   Int_t       iX, iY, iZ, iT, iHit;
   const Int_t nHit = gAnalyzer->GetHitSize();

   // clustering
   for (iX = 0; iX < 4; iX++) {
      for (iY = 0; iY < 4; iY++) {
         for (iZ = 0; iZ < 4; iZ++) {
            for (iT = 0; iT < 4; iT++) {
               iCluster = iX * 4 * 4 * 4 + iY * 4 * 4 + iZ * 4 + iT;
               cluster[iCluster] = new TObjArray();
               for (iHit = 0; iHit < nHit; iHit++) {
                  if (gAnalyzer->GetHitAt(iHit)->GetX() > iX * 2.5 &&
                      gAnalyzer->GetHitAt(iHit)->GetX() < (iX + 1) * 2.5 &&
                      gAnalyzer->GetHitAt(iHit)->GetY() > iY * 2.5 &&
                      gAnalyzer->GetHitAt(iHit)->GetY() < (iY + 1) * 2.5 &&
                      gAnalyzer->GetHitAt(iHit)->GetZ() > iZ * 2.5 &&
                      gAnalyzer->GetHitAt(iHit)->GetZ() < (iZ + 1) * 2.5 &&
                      gAnalyzer->GetHitAt(iHit)->GetT() > iT * 25e-9 &&
                      gAnalyzer->GetHitAt(iHit)->GetT() < (iT + 1) * 25e-9) {
                     cluster[iCluster]->Add(gAnalyzer->GetHitAt(iHit));
                     hitID[iCluster].Set(hitID[iCluster].GetSize() + 1);
                     hitID[iCluster].AddAt(iHit, hitID[iCluster].GetSize() - 1);
                  }
               }
            }
         }
      }
   }

   // count number of non-empty clusters
   Int_t nCluster = 0;
   for (iCluster = 0; iCluster < kMaxCluster; iCluster++) {
      if (cluster[iCluster]->GetEntries()) {
         nCluster++;
      }
   }
   gAnalyzer->SetClusterSize(nCluster);

   // fill Cluster folder
   Int_t    iClusterForFill = 0;
   REFHit*  firstHit;
   Int_t    firstHitID;
   Double_t xSum, ySum, zSum, tSum;
   for (iCluster = 0; iCluster < kMaxCluster; iCluster++) {
      if (cluster[iCluster]->GetEntries()) {
         firstHit = 0;
         firstHitID = 0;
         xSum = ySum = zSum = tSum = 0;
         gAnalyzer->GetClusterAt(iClusterForFill)->SetHitSize(cluster[iCluster]->GetEntries());
         gAnalyzer->GetClusterAt(iClusterForFill)->SetHitIDSize(cluster[iCluster]->GetEntries());
         for (iHit = 0; iHit < cluster[iCluster]->GetEntries(); iHit++) {
            xSum += dynamic_cast<REFHit*>(cluster[iCluster]->At(iHit))->GetX();
            ySum += dynamic_cast<REFHit*>(cluster[iCluster]->At(iHit))->GetY();
            zSum += dynamic_cast<REFHit*>(cluster[iCluster]->At(iHit))->GetZ();
            tSum += dynamic_cast<REFHit*>(cluster[iCluster]->At(iHit))->GetT();
            gAnalyzer->GetClusterAt(iClusterForFill)->SetHitAt(iHit, cluster[iCluster]->At(iHit));
            gAnalyzer->GetClusterAt(iClusterForFill)->SetHitIDAt(iHit, hitID[iCluster].At(iHit));
            if (!firstHit || dynamic_cast<REFHit*>(cluster[iCluster]->At(iHit))->GetT() < firstHit->GetT()) {
               firstHit = dynamic_cast<REFHit*>(cluster[iCluster]->At(iHit));
               firstHitID = hitID[iCluster].At(iHit);
            }
         }
         gAnalyzer->GetClusterAt(iClusterForFill)->SetFirstHit(firstHit);
         gAnalyzer->GetClusterAt(iClusterForFill)->SetFirstHitID(firstHitID);
         gAnalyzer->GetClusterAt(iClusterForFill)->SetX(xSum / cluster[iCluster]->GetEntries());
         gAnalyzer->GetClusterAt(iClusterForFill)->SetY(ySum / cluster[iCluster]->GetEntries());
         gAnalyzer->GetClusterAt(iClusterForFill)->SetZ(zSum / cluster[iCluster]->GetEntries());
         gAnalyzer->GetClusterAt(iClusterForFill)->SetT(tSum / cluster[iCluster]->GetEntries());
         iClusterForFill++;
      }
   }

   // search for the largest cluster
   REFCluster* largestCluster = 0;
   Int_t iLargestCluster = 0;
   Int_t maxClusterSize = 0;
   for (iCluster = 0; iCluster < gAnalyzer->GetClusterSize(); iCluster++) {
      if (!largestCluster || maxClusterSize < gAnalyzer->GetClusterAt(iCluster)->GetHitSize()) {
         largestCluster = gAnalyzer->GetClusterAt(iCluster);
         iLargestCluster = iCluster;
         maxClusterSize = gAnalyzer->GetClusterAt(iCluster)->GetHitSize();
      }
   }
   gAnalyzer->GetMainCluster()->SetLargestCluster(largestCluster);
   gAnalyzer->GetMainCluster()->SetLargestClusterID(iLargestCluster);

   for (iCluster = 0; iCluster < kMaxCluster; iCluster++) {
      delete cluster[iCluster];
   }
   delete [] hitID;
   delete [] cluster;
}

//______________________________________________________________________________
void REFTClustering::EndOfRun()
{
}

//______________________________________________________________________________
void REFTClustering::Terminate()
{
}

