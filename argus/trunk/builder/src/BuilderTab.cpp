/********************************************************************

  BuilderTab.cpp, Ryu Sawada

  $Log$
  Revision 1.2  2005/01/30 20:39:39  sawada
  * Makefile of builder
  * Tab enable/disable
  * Bug fix.(fNetFolder, ConnectServer)

  Revision 1.1.1.1  2005/01/29 22:45:08  sawada
  Advanced Root based GUi monitoring System


********************************************************************/
#include "ArgusBuilder.h"

bool ArgusBuilder::ReadXMLTab() {
   // read the tab definitions out of the xml file
   ROMEString tmp;
   char* name;
   int type,i,j;
   ROMEString currentTabName = "";
   int currentNumberOfTabs;
   // count tabs
   numOfTab++;
   currentNumberOfTabs = numOfTab;
   if (numOfTab>=maxNumberOfTabs) {
      cout << "Maximal number of tabs reached : " << maxNumberOfTabs << " !" << endl;
      cout << "Terminating program." << endl;
      return false;
   }
   // initialisation
   tabName[numOfTab] = "";
   tabTitle[numOfTab] = "";
   tabAuthor[numOfTab] = mainAuthor;
   tabVersion[numOfTab] = "1";
   tabDescription[numOfTab] = "";
   numOfSteering[numOfTab] = -1;
   while (xml->NextLine()) {
      type = xml->GetType();
      name = xml->GetName();
      // subtab
      if (type == 1 && !strcmp((const char*)name,"Tab")) {
         // set tab as parent for subsequent tabs
         recursiveTabDepth++;
         parent[recursiveTabDepth] = tabName[numOfTab];
         // read subtab
         if (!ReadXMLTab()) 
            return false;
         continue;
      }
      // end tab
      if (type == 15 && !strcmp((const char*)name,"Tab")) {
         // check input
         if (currentTabName=="") {
            cout << "The " << (currentNumberOfTabs+1) << ". Tab has no name !" << endl;
            cout << "Terminating program." << endl;
            return false;
         }
         return true;
      }
      // tab name
      if (type == 1 && !strcmp((const char*)name,"TabName")) {
         xml->GetValue(tabName[numOfTab],tabName[numOfTab]);
         currentTabName = tabName[numOfTab];
         // output
         if (makeOutput) for (i=0;i<recursiveTabDepth;i++) cout << "   ";
         if (makeOutput) tabName[numOfTab].WriteLine();
      }
      // tab title
      if (type == 1 && !strcmp((const char*)name,"TabTitle"))
         xml->GetValue(tabTitle[numOfTab],tabTitle[numOfTab]);
      // tab author
      if (type == 1 && !strcmp((const char*)name,"Author"))
         xml->GetValue(tabAuthor[numOfTab],tabAuthor[numOfTab]);
      // tab version
      if (type == 1 && !strcmp((const char*)name,"TabVersion"))
         xml->GetValue(tabVersion[numOfTab],tabVersion[numOfTab]);
      // tab description
      if (type == 1 && !strcmp((const char*)name,"TabDescription"))
         xml->GetValue(tabDescription[numOfTab],tabDescription[numOfTab]);
      // tab steering parameters
      if (type == 1 && !strcmp((const char*)name,"SteeringParameters")) {
         // read steering parameter
         steerName[numOfTab][0] = "Steering";
         steerParent[numOfTab][0] = -1;
         actualSteerIndex = 0;
         recursiveSteerDepth = 0;
         if (!ReadXMLSteering(numOfTab)) 
            return false;
         numOfSteering[numOfTab]++;
      }
   }
   return true;
}

bool ArgusBuilder::WriteTabCpp() {
   ROMEString cppFile;
   ROMEString buffer;
   char fileBuffer[bufferLength];
   int lenTot,ll,i,j;
   char *pBuffer=NULL;
   int bufferLen=0;
   char *pos;
   int fileHandle;
   ROMEString format;
   ROMEString discript;
   ROMEString str;
   if (makeOutput) cout << "\n   Output Cpp-Files:" << endl;
   for (int iTab=0;iTab<numOfTab;iTab++) {
      // File name
      cppFile.SetFormatted("%s/src/tabs/%sT%s.cpp",outDir.Data(),shortCut.Data(),tabName[iTab].Data());
      // Description
      buffer.Resize(0);
      buffer.AppendFormatted("//// Author: %s\n",tabAuthor[iTab].Data());
      buffer.AppendFormatted("////////////////////////////////////////////////////////////////////////////////\n");
      buffer.AppendFormatted("//                                                                            //\n");
      ll = 73-shortCut.Length();
      format.SetFormatted("// %%sT%%-%d.%ds //\n",ll,ll);
      buffer.AppendFormatted((char*)format.Data(),shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("//                                                                            //\n");
      discript = tabDescription[iTab].Data();
      pos = (char*)discript.Data();
      lenTot = discript.Length();
      while (pos-discript.Data() < lenTot) {
         if (lenTot+(discript.Data()-pos)<74) 
            i=lenTot+(discript.Data()-pos);
         else for (i=74;pos[i]!=32&&i>0;i--) {}
         if (i<=0)
            i=TMath::Min(75,lenTot);
         pos[i] = 0;
         buffer.AppendFormatted("// %-74.74s   \n",pos);
         pos = pos+i+1;
      }
      buffer.AppendFormatted("// \n");
      buffer.AppendFormatted("// \n");
      buffer.AppendFormatted("// This header has been generated by the ArgusBuilder.\n");
      buffer.AppendFormatted("//                                                                            //\n");
      buffer.AppendFormatted("/////////////////////////////////////----///////////////////////////////////////");
      // Write file
      bool replaceHeader = true;
      bool replaceBody = true;
      struct stat buf;
      int nb=0;
      if( !stat( cppFile.Data(), &buf )) {
         replaceBody = false;
         fileHandle = open(cppFile.Data(),O_RDONLY);
         nb = read(fileHandle,&fileBuffer, sizeof(fileBuffer));
         pBuffer = fileBuffer;
         char *pend = "/////////////////////////////////////----///////////////////////////////////////";
         pBuffer = strstr(pBuffer,pend);
         if (pBuffer==NULL) {
            if (makeOutput) cout << "\n\nError : File '" << cppFile.Data() << "' has an invalid header !!!" << endl;
            replaceHeader = false;
         }
         bufferLen = nb-(pBuffer-fileBuffer);
         close(fileHandle);
         if (replaceHeader) {
            replaceHeader = false;
            for (i=0;i<pBuffer-fileBuffer;i++) {
               if (buffer[i] != fileBuffer[i]) {
                  replaceHeader = true;
               }
            }
         }
      }
      if (replaceHeader || replaceBody) {
         fileHandle = open(cppFile.Data(),O_TRUNC  | O_CREAT,S_IREAD | S_IWRITE  );
         close(fileHandle);
         fileHandle = open(cppFile.Data(),O_RDWR  | O_CREAT,S_IREAD | S_IWRITE  );
         if (makeOutput) cout << "      " << cppFile.Data() << endl;
         if (replaceHeader) {
            nb = write(fileHandle,buffer.Data(), buffer.Length());
         }
         if (replaceBody) {
            buffer.Resize(0);
            // Header
            buffer.AppendFormatted("\n\n#include \"include/tabs/%sT%s.h\"\n",shortCut.Data(),tabName[iTab].Data());
            buffer.AppendFormatted("\nClassImp(%sT%s)\n\n",shortCut.Data(),tabName[iTab].Data());
            // Functions
            buffer.AppendFormatted("//Destructer\n");
            buffer.AppendFormatted("%sT%s::~%sT%s()\n{\n}\n\n",shortCut.Data(),tabName[iTab].Data(),shortCut.Data(),tabName[iTab].Data());
            buffer.AppendFormatted("//Constructer\n");
            buffer.AppendFormatted("%sT%s::%sT%s(const TGWindow *p, UInt_t w, UInt_t h, UInt_t options,\n",shortCut.Data(),tabName[iTab].Data(),shortCut.Data(),tabName[iTab].Data());
            buffer.AppendFormatted("Pixel_t back):%sT%s_Base(p, w, h, options, back) \n{\n}\n",shortCut.Data(),tabName[iTab].Data(),shortCut.Data(),tabName[iTab].Data());
	    buffer.AppendFormatted("\n");
            buffer.AppendFormatted("void %sT%s::Init()\n",shortCut.Data(),tabName[iTab].Data());
            buffer.AppendFormatted("{\n");
            buffer.AppendFormatted("}\n");
            nb = write(fileHandle,buffer.Data(), buffer.Length());
         }
         else {
            nb = write(fileHandle,pBuffer+80, bufferLen-80);
         }
         close(fileHandle);
      }
   }
   return true;
}

bool ArgusBuilder::WriteTabH() {
   ROMEString hFile;
   ROMEString buffer;
   char fileBuffer[bufferLength];
   ROMEString format;
   int i,j;
   int fileHandle;
   if (makeOutput) cout << "\n   Output H-Files:" << endl;
   for (int iTab=0;iTab<numOfTab;iTab++) {
      // File name
      hFile.SetFormatted("%s/include/tabs/%sT%s_Base.h",outDir.Data(),shortCut.Data(),tabName[iTab].Data());
      // Description
      buffer.Resize(0);
      buffer.AppendFormatted("////////////////////////////////////////////////////////////////////////////////\n");
      buffer.AppendFormatted("//                                                                            //\n");
      buffer.AppendFormatted("// This file has been generated by the ROMEBuilder.                           //\n");
      buffer.AppendFormatted("// Manual changes to this file will always be overwritten by the builder.     //\n");
      buffer.AppendFormatted("//                                                                            //\n");
      buffer.AppendFormatted("////////////////////////////////////////////////////////////////////////////////\n\n");
      // Header
      buffer.AppendFormatted("#ifndef %sT%s_Base_H\n",shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("#define %sT%s_Base_H\n\n",shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("#include <TGFrame.h>\n");
      buffer.AppendFormatted("#include \"include/monitor/%sMonitor.h\"\n",shortCut.Data());
      // Class
      buffer.AppendFormatted("\nclass %sT%s_Base : public TGCompositeFrame\n",shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("{\n");
      buffer.AppendFormatted("protected:\n");
      // Fields
      if (numOfSteering[iTab]>0) {
         WriteSteeringClass(buffer,0,iTab,1);
         buffer.AppendFormatted("\n");
      }
      buffer.AppendFormatted("   Int_t fVersion; // Version number\n");
      if (numOfSteering[iTab]>0) {
         buffer.AppendFormatted("   Steering* fSteering; // Handle to Steering class\n\n");
      }
      int nameLen = -1;
      // Methods
      buffer.AppendFormatted("public:\n");
      // Constructor
      buffer.AppendFormatted("   // Constructor\n");

      buffer.AppendFormatted("   %sT%s_Base(const TGWindow *p, UInt_t w, UInt_t h, UInt_t options, Pixel_t back):TGCompositeFrame(p, w, h, options, back){\n",shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("      fVersion = %s;\n",tabVersion[iTab].Data());
      if (numOfSteering[iTab]>0) {
         buffer.AppendFormatted("      fSteering = new Steering();\n");
      }
      buffer.AppendFormatted("   }\n");
      // User Methods
      buffer.AppendFormatted("   // User Methods\n");
      if (numOfSteering[iTab]>0) {
         buffer.AppendFormatted("   Steering* GetSteeringParameters() { return fSteering; };\n");
         buffer.AppendFormatted("   Steering* GetSP() { return fSteering; };\n");
      }
      buffer.AppendFormatted("protected:\n");
      buffer.AppendFormatted("   // Event Methods\n");
      // Footer
      buffer.AppendFormatted("\n   ClassDef(%sT%s_Base,%s)\n",shortCut.Data(),tabName[iTab].Data(),tabVersion[iTab].Data());
      buffer.AppendFormatted("};\n\n");
      buffer.AppendFormatted("#endif   // %sT%s_Base_H\n",shortCut.Data(),tabName[iTab].Data());
      // Write File
      fileHandle = open(hFile.Data(),O_RDONLY);
      int nb = read(fileHandle,&fileBuffer, sizeof(fileBuffer));
      bool identical = true;
      if (nb==(int)buffer.Length()) {
         for (i=0;i<nb&&i<(int)buffer.Length();i++) {
            if (buffer[i] != fileBuffer[i]) {
               identical = false;
               break;
            }
         }
      }
      else
         identical = false;
      if (!identical) {
         fileHandle = open(hFile.Data(),O_TRUNC  | O_CREAT,S_IREAD | S_IWRITE  );
         close(fileHandle);
         fileHandle = open(hFile.Data(),O_RDWR  | O_CREAT,S_IREAD | S_IWRITE  );
         if (makeOutput) cout << "      " << hFile.Data() << endl;
         nb = write(fileHandle,buffer.Data(), buffer.Length());
         close(fileHandle);
      }
      // User H-File
      struct stat buf;
      hFile.SetFormatted("%s/include/tabs/%sT%s.h",outDir.Data(),shortCut.Data(),tabName[iTab].Data());
      // Description
      buffer.Resize(0);
      buffer.AppendFormatted("////////////////////////////////////////////////////////////////////////////////\n");
      buffer.AppendFormatted("//                                                                            //\n");
      buffer.AppendFormatted("// Editable class file for %s tab.\n",tabName[iTab].Data());
      buffer.AppendFormatted("//                                                                            //\n");
      buffer.AppendFormatted("////////////////////////////////////////////////////////////////////////////////\n\n");
      // Header
      buffer.AppendFormatted("#ifndef %sT%s_H\n",shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("#define %sT%s_H\n\n",shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("#include <include/tabs/%sT%s_Base.h>\n",shortCut.Data(),tabName[iTab].Data());
      // Class
      buffer.AppendFormatted("\nclass %sT%s : public %sT%s_Base\n",shortCut.Data(),tabName[iTab].Data(),shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("{\n");
      buffer.AppendFormatted("public:\n");
      // Constructor
      buffer.AppendFormatted("   %sT%s(const TGWindow *p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0,\n",shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("         Pixel_t back = GetDefaultFrameBackground());\n",shortCut.Data(),tabName[iTab].Data(),shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("   virtual ~%sT%s();\n",shortCut.Data(),tabName[iTab].Data());
      buffer.AppendFormatted("   void Init();\n");
      // Fields
      buffer.AppendFormatted("\n   ClassDef(%sT%s,%s)\n",shortCut.Data(),tabName[iTab].Data(),tabVersion[iTab].Data());
      buffer.AppendFormatted("};\n\n");
      buffer.AppendFormatted("#endif   // %sT%s_H\n",shortCut.Data(),tabName[iTab].Data());
      // Write File
      if(open(hFile.Data(),O_RDONLY) == -1){
         fileHandle = open(hFile.Data(),O_TRUNC  | O_CREAT,S_IREAD | S_IWRITE  );
         close(fileHandle);
         fileHandle = open(hFile.Data(),O_RDWR  | O_CREAT,S_IREAD | S_IWRITE  );
         if (makeOutput) cout << "      " << hFile.Data() << endl;
         nb = write(fileHandle,buffer.Data(), buffer.Length());
         close(fileHandle);
      }
   }
   return true;
}

bool ArgusBuilder::WriteTabConfigWrite(ROMEString &buffer,int parentIndex,ROMEString& pointer,int tab) {
   int j,i;
   // max tab switch name length
   int switchLen = -1;
   ROMEString switchString;
   for (i=0;i<numOfTabHierarchy;i++) {
      int index = tabHierarchyParentIndex[i];
      switchString = tabHierarchyName[i].Data();
      while (index!=-1) {
         switchString.Insert(0,"_");
         switchString.Insert(0,tabHierarchyName[index].Data());
         index = tabHierarchyParentIndex[index];
      }
      if (switchLen<(int)switchString.Length()) switchLen = switchString.Length();
   }
   ROMEString blank = "";
   for (i=0;i<tab;i++)
      blank.Append("   ");
   ROMEString pointerI;
   for (i=0;i<numOfTabHierarchy;i++) {
      if (tabHierarchyParentIndex[i]!=parentIndex)
         continue;
      int index = tabHierarchyParentIndex[i];
      switchString = tabHierarchyName[i].Data();
      while (index!=-1) {
         switchString.Insert(0,"_");
         switchString.Insert(0,tabHierarchyName[index].Data());
         index = tabHierarchyParentIndex[index];
      }
      pointerI = pointer;
      pointerI.AppendFormatted("->f%sTab",tabHierarchyName[i].Data());
      buffer.AppendFormatted("%s      if (fConfigData[index]%sModified || index==0) {\n",blank.Data(),pointerI.Data());
      buffer.AppendFormatted("%s         // %s\n",blank.Data(),pointerI.Data());
      buffer.AppendFormatted("%s         xml->StartElement(\"Tab\");\n",blank.Data());
      buffer.AppendFormatted("%s         xml->WriteElement(\"TabName\",\"%s\");\n",blank.Data(),tabHierarchyName[i].Data());
      buffer.AppendFormatted("%s         if (index==0) {\n",blank.Data());
      buffer.AppendFormatted("%s            if (gWindow->GetTabSwitches()->%s)\n",blank.Data(),switchString.Data());
      buffer.AppendFormatted("%s               xml->WriteElement(\"Active\",\"true\");\n",blank.Data());
      buffer.AppendFormatted("%s            else\n",blank.Data());
      buffer.AppendFormatted("%s               xml->WriteElement(\"Active\",\"false\");\n",blank.Data());
      buffer.AppendFormatted("%s         }\n",blank.Data());
      buffer.AppendFormatted("%s         else if (fConfigData[index]%s->fActiveModified)\n",blank.Data(),pointerI.Data());
      buffer.AppendFormatted("%s            xml->WriteElement(\"Active\",(char*)fConfigData[index]%s->fActive.Data());\n",blank.Data(),pointerI.Data());
      // Steering parameter
      if (numOfSteering[tabHierarchyClassIndex[i]]>0) {
         buffer.AppendFormatted("%s         // steering parameters\n",blank.Data());
         buffer.AppendFormatted("%s         if (fConfigData[index]%s->fSteeringModified || index==0) {\n",blank.Data(),pointerI.Data());
         buffer.AppendFormatted("%s            ROMEString value;\n",blank.Data());
         ROMEString pointerT;
         ROMEString steerPointerT;
         pointerT.SetFormatted("fConfigData[index]%s->fSteering",pointerI.Data());
         steerPointerT.SetFormatted("((%sT%s*)gWindow->Get%s%03dTab())->GetSP()",shortCut.Data(),tabName[tabHierarchyClassIndex[i]].Data(),tabHierarchyName[i].Data(),i);
         WriteSteeringConfigWrite(buffer,0,tabHierarchyClassIndex[i],pointerT,steerPointerT,3+tab);
      }
      if (numOfSteering[tabHierarchyClassIndex[i]]>0)
         buffer.AppendFormatted("%s         }\n",blank.Data());

      WriteTabConfigWrite(buffer,i,pointerI,tab+1);
      buffer.AppendFormatted("%s         xml->EndElement();\n",blank.Data());
      buffer.AppendFormatted("%s      }\n",blank.Data());
   }
   return true;
}

bool ArgusBuilder::WriteTabConfigClass(ROMEString &buffer,int parentIndex,int tab) {
   int j,i;
   ROMEString blank = "";
   for (i=0;i<tab;i++)
      blank.Append("   ");
   for (i=0;i<numOfTabHierarchy;i++) {
      if (tabHierarchyParentIndex[i]!=parentIndex)
         continue;
      buffer.AppendFormatted("%s      class %sTab {\n",blank.Data(),tabHierarchyName[i].Data());
      buffer.AppendFormatted("%s         public:\n",blank.Data());
      buffer.AppendFormatted("%s            ROMEString  fActive;\n",blank.Data());
      buffer.AppendFormatted("%s            bool        fActiveModified;\n",blank.Data());
      if (numOfSteering[tabHierarchyClassIndex[i]]>0) {
         buffer.AppendFormatted("%s         // steering parameters\n",blank.Data());
         buffer.AppendFormatted("%s         class Steering {\n",blank.Data());
         buffer.AppendFormatted("%s         public:\n",blank.Data());
         WriteSteeringConfigClass(buffer,0,tabHierarchyClassIndex[i],tab+3);
         buffer.AppendFormatted("%s         };\n",blank.Data());
         buffer.AppendFormatted("%s         Steering *fSteering;\n",blank.Data());
         buffer.AppendFormatted("%s         bool   fSteeringModified;\n",blank.Data());
      }
      // Constructor
      buffer.AppendFormatted("%s      public:\n",blank.Data());
      buffer.AppendFormatted("%s         %sTab() {\n",blank.Data(),tabHierarchyName[i].Data());
      if (numOfSteering[tabHierarchyClassIndex[i]]>0) {
         buffer.AppendFormatted("%s            fSteeringModified = false;\n",blank.Data());
         buffer.AppendFormatted("%s            fSteering = new Steering();\n",blank.Data());
      }
      for (j=0;j<numOfTabHierarchy;j++) {
         if (tabHierarchyParentIndex[j]!=i)
            continue;
         buffer.AppendFormatted("%s            f%sTab = new %sTab();\n",blank.Data(),tabHierarchyName[j].Data(),tabHierarchyName[j].Data());
      }
      buffer.AppendFormatted("%s         };\n",blank.Data());
      // Sub classes
      WriteTabConfigClass(buffer,i,tab+1);
      buffer.AppendFormatted("%s      };\n",blank.Data());
      buffer.AppendFormatted("%s      %sTab *f%sTab;\n",blank.Data(),tabHierarchyName[i].Data(),tabHierarchyName[i].Data());
      buffer.AppendFormatted("%s      bool   f%sTabModified;\n",blank.Data(),tabHierarchyName[i].Data());
   }
   return true;
}
