//// Author: Matthias Schneebeli
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// MEGTReadMidas                                                              //
//                                                                            //
// Reads Midas Data.                                                            
//                                                                            //
//                                                                            //
// This file has been generated by the ROMEBuilder.                           //
//                                                                            //
// This task contains the following histgrams :
//
// The histograms are created and saved automaticaly by the task.
//
// The following methods can be used to fill the histogram and to set the
// right name,title and binwidth of the histogram :
//
// Fill<Histogram Name>(double value,double weight)
//
// For histogram arrays use :
//
// Fill<Histogram Name>At(int index,double value,double weight)
//
// If more histogram functions are needed use the following function the get
// a handle to the histogram and use the root functions.
//
// Get<Histogram Name>Handle()
//
// For histogram arrays use :
//
// Get<Histogram Name>HandleAt(int index)
//                                                                            //
/////////////////////////////////////----///////////////////////////////////////

#if defined( _MSC_VER )
#include <io.h>
#define O_RDONLY_BINARY O_RDONLY | O_BINARY
#endif
#if defined ( __linux__ )
#include <unistd.h>
#include <stdlib.h>
#include <sys/io.h>
#include <sys/types.h>
#include <sys/stat.h>
#define O_RDONLY_BINARY O_RDONLY
#endif

#include <TFile.h>
#include <ROME.h>
#include <ROMEStatic.h>
#include <include/tasks/MEGTReadMidas.h>
#include <Riostream.h>

ClassImp(MEGTReadMidas)


void MEGTReadMidas::Init()
{
}

void MEGTReadMidas::BeginOfRun()
{
}
int ii = 0;
void MEGTReadMidas::Event()
{
   ii++;
   if (ii%2) {
      fAnalyzer->SetDontReadNextEvent();
   }
   fAnalyzer->SetCurrentEventNumber(ii);

   // Read Midas Banks and fill theme to folder
   float invalid = fAnalyzer->GetGeneralSteeringParameters()->GetInvalidValue();

   const int nPMT = fAnalyzer->GetGeneralSteeringParameters()->GetPMT()->GetNumbers()->GetNumberOfPMT();
   const int nFTDC = fAnalyzer->GetGeneralSteeringParameters()->GetPMT()->GetNumbers()->GetNumberOfFTDC();
   const int nCTDC = fAnalyzer->GetGeneralSteeringParameters()->GetPMT()->GetNumbers()->GetNumberOfCTDC();
   const int nVTDC = fAnalyzer->GetGeneralSteeringParameters()->GetPMT()->GetNumbers()->GetNumberOfVTDC();

   Int_t i;
   Float_t  *vfTDC = new Float_t[nPMT];
   int channel=0;float time=0,k;
   int n_f,n_c,n_v;

   // Read Banks

   // TDC Banks
   n_f = fAnalyzer->GetFTDCBankEntries();
   n_c = fAnalyzer->GetCTDCBankEntries();
   if (n_f == nFTDC && n_c == nCTDC) {
      for (i=nFTDC;i<nPMT;i++) vfTDC[i] = invalid;
 
      // FTDC Bank
      for (i=0;i<nFTDC;i++) {
         vfTDC[i] = (Float_t)(0.025f*fAnalyzer->GetFTDCBankAt(i)->data);
      }

      // CTDC Bank
      for (i=0;i<nCTDC;i++) {
         for (k=0,channel=0 ; k<5 && (int)(fAnalyzer->GetCTDCBankAt(i)>>16) != 19+k ; k++){
            channel += 16;
         }
         channel += (fAnalyzer->GetCTDCBankAt(i) >> 12) & 0xF;
         channel += nFTDC;
         time = (float) (fAnalyzer->GetCTDCBankAt(i) & 0xFFF);
         if (time >= 1.f && time < 4096.0f) {
            time *= 0.025f;
            if(channel < nFTDC + nCTDC) {
               vfTDC[channel] = time;
            }
         }
         else vfTDC[channel] = invalid;
      }

      // VTDC Bank
      n_v = fAnalyzer->GetVTDCBankEntries();
      for (i=0;i<n_v;i++) {
         if(fAnalyzer->GetVTDCBankAt(i)->tag == 0) {//( tag = 0:data, 2:header, 4:EOB 
	         channel = nFTDC + nCTDC; // put VME TDCs after FB&Camac TDCs 
	         channel += fAnalyzer->GetVTDCBankAt(i)->geo_addr*32;
	         channel += fAnalyzer->GetVTDCBankAt(i)->channel;
	         time = fAnalyzer->GetVTDCBankAt(i)->data;
	         // convert to ns 
	         time *= 0.035f;
	         if (channel < nPMT) {
               // fill histos with TDC value 
	            vfTDC[channel] = time;
            }
         }
      }
   }
   else {
      fAnalyzer->SetFillEvent(false);
      delete vfTDC;
      return;
   }
   // write data to folder
   int iadc,itdc;
   for (i=0;i<nPMT;i++) {
      iadc = fAnalyzer->GetCMPMTInfoAt(i)->GetADCID();
      itdc = fAnalyzer->GetCMPMTInfoAt(i)->GetTDCID();
      fAnalyzer->GetCMPMTDataAt(i)->SetADC0Data((Float_t)fAnalyzer->GetADC0BankAt(iadc));
      fAnalyzer->GetCMPMTDataAt(i)->SetADC1Data((Float_t)fAnalyzer->GetADC1BankAt(iadc));
      fAnalyzer->GetCMPMTDataAt(i)->SetTDCData(vfTDC[itdc]);
   }
	  
   delete vfTDC;
   return;
}

void MEGTReadMidas::EndOfRun()
{
}

void MEGTReadMidas::Terminate()
{
}


